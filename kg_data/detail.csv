id,name,desc,English
0,数据,指所有能被输入到计算机中，且能被计算机处理的符号的总称。如：实数、整数、字符（串）、图形和声音等。,
1,数据元素,是数据（集合）中的一个“个体”，是数据结构中讨论的基本单位，不同场合也叫结点、顶点、记录。,
2,数据项,是数据结构中讨论的最小单位，数据元素是由若干个数据项组成。,
3,数据结构,指数据相互之间存在一种或多种关系的数据元素的集合。,
4,逻辑结构,"数据的逻辑结构描述数据元素和数据元素之间的关系两方面的内容，因此逻辑结构可用二元组形式定义为:Data_Structures = (D, R)，其中: D 是数据元素的有限集合，R是 D上关系的有限集合，描述了D中数据元素之间的关联关系。",
5,存储结构,是逻辑结构在计算机中的表示，即是逻辑结构在存储器中的映象。,
6,顺序映像,指以相对的存储位置来表示数据元素之间的逻辑关系。,
7,链式映像,指以附加信息(指针)表示后继关系。,
8,数据的操作,即数据的运算，是对数据进行某种方法的处理。常用的操作有：创建、销毁、插入、删除、查找、修改、遍历。,
9,抽象数据类型,是指一数据值的集合和定义在这个集合上的一组操作。,
10,算法,算法是对特定问题求解步骤的一种描述。严格来讲，一个算法一般应具有以下5种性质：1．有穷性  2．确定性   3．有效性 4．输入  5．输出。,
11,时间复杂度,算法的时间复杂度为 T (n) = O(f(n))，当且仅当存在正常数c和N，对所有的n(n≥N)满足0≤T(n) ≤c×f(n)。,
12,线性表,"一个线性表（Linear List）是由n(n≥0)个数据元素（结点）所构成的有限序列。线性表逻辑地表示为：（a0,a1,…,an-1)。其中，n为线性表的长度，n=0时为空表。称i为ai在线性表中的位序号。",
13,顺序存储,用一组地址连续的存储单元依次存放 线性表中的数据元素的存储结构。,
14,顺序表,用顺序存储的线性表就称为顺序表。,
15,插入操作的算法步骤,a.检测空间是否足够及参数i是否合法；b.插入位置及之后的所有元素后移一个位置；c.插入；d.修正表长：表长加1。,
16,删除操作的算法步骤,a.检测参数i是否合法；b.插入之后的所有元素前移一个位置；c.修正表长：表长减1。,
17,查找操作的要求,"查找数据元素x在顺序表中是否存在,若存在则函数返回x初次出现的位置,否则返回-1。",
18,头指针,指以线性表中第一个数据元素a0的存储地址作为线性表的地址，称作线性表的头指针。,
19,单链表的表示,用一组地址任意的存储单元存放线性表中的数据元素。以元素(数据元素的映象)+指针(指示后继元素存储位置) =结点(表示数据元素或数据元素的映象)；以“结点的序列”表示线性表，称作链表,
20,按位序号查找操作 get(i）的实现,分析：单链表是一种"顺序存取"的结构，即：为取第 i 元素，首先必须先找到第 i-1 个元素。因此不论 i 值为多少，都必须从头结点开始起"点数"，直数到第 i 个为止。头结点可看成是第1个结点。,
21,按值查找操作 indexOf(x）的实现,分析：从单链表的首结点开始沿着后继指针依次对各结点的数据域值与x值进行比较，直到找到数据域值为x的结点或到达单链表的表尾为止。,
22,"单链表上插入操作insert(i,x)实现",要求：在带头结点的单链表的第i个结点之前插入一个数据域值为x的新结点，其中 0≤i≤n 。,
23,单链表上删除操作remove(i)实现,要求：删除带头结点单链表中的第i个结点，其中 0≤i≤n-1。 ,
24,循环链表,最后一个结点的指针域的指针又指回第一个结点所形成的链表称为循环链表。,
25,栈,"栈是仅限制在表尾进行插入和删除操作的特殊线性表，限制操作的表尾端称为“栈顶”, 另一端称为“栈底”。栈是“后进先出”的线性表（LIFO）或 “先进后出”的线性表（FILO）。",
26,栈的基本操作,1）栈的置空操作：clear(  )；2）栈的判空操作：isEmpty(  )；3）求栈的长度：length(  )；4）取栈顶元素操作：peek(  )；5）入栈操作：push( x )；6）出栈操作：pop( ),
27,顺序栈的入栈操作push (x)的实现,（1）操作要求：插入元素x使其成为顺序栈中新的栈顶元素。(2) 算法步骤：a.判断顺序栈是否为满，若满则抛出异常； b.若栈不满，则将新元素x 压入栈顶，并修正栈顶指针。,
28,顺序栈的出栈操作pop( )的实现,(1) 操作要求：将栈顶元素从栈中移去，并返回被移去的栈顶元素值。(2)算法步骤：a）若栈空，则返回空值；b)若栈不空，则移去栈顶元素并返回其值。,
29,链栈,栈的链式存储结构称为链栈，是运算受限的单链表，其插入和删除操作仅限制在链表的表头位置上进行，链栈没有必要附加头结点，栈顶指针top指向栈顶元素结点。 ,
30,链栈的长度操作length ()的实现,操作要求：计算出链栈中所包含的数据元素的个数并返回其值。  ,
31,链栈的入栈操作push(x)的实现,操作要求：将数据域值为x的新结点插入到链栈的栈顶，使其成为新的栈顶元素。 ,
32,链栈的出栈操作pop( )的实现,操作要求：将首结点（或栈顶结点）从链栈中移去，并返回该结点的数据域的值。,
33,队列,队列是只允许在表的一端进行插入，而在表的另一端进行删除操作的一种特殊线性表。允许插入的一端称为“队尾”，允许删除的一端称为“队首”。,
34,队列的基本操作,1）队列的置空操作：clear(  )；2）队列的判空操作：isEmpty(  )；3）求队列的长度：length(  )；4）取队首元素操作：peek(  )；5）入队操作：offer( x )；6）出队操作：poll ( ),
35,循环顺序队列,指将顺序队列看成是首尾相联的队列。,
36,循环顺序队列的出队操作poll( )的实现,（1）基本要求：将队首元素删除，并返回其值。（2）操作步骤 ：1）若队空，则返回空值；2）若队非空，则返回队首元素且首指针加1。,
37,链队列,队列的链式存储结构称为链队列，其链式存储结构在此用不带头结点的单链表来实现。,
38,链队列的入队操作 offer(x)的实现,1.操作要求：插入新元素x使其成为新的队尾元素。 2.操作步骤：a）产生新的结点p：Node p = new Node(x); b）将新结点插入链队的尾部（修改链）,
39,链队列的出队操作 poll()的实现,"1.操作要求：移去队首元素并返回其值；2.操作步骤：a）若队列为空,则返回空值；b）若队列非空,则移去队首元素；c) 若删除的是队尾元素，则修改队尾指针；d) 返回队尾元素值。",
40,优先队列,"优先级队列是一种带有优先级的队列,并且按优先级从大到小有序排列，也有顺序和链式两种存储结构。",
41,串,"是指由零个或多个字符组成的有限序列。一般记为s= "" a0a1…an-1 "", 其中s为串名，双引号括起来的字符序列是串值。串也是一种特殊的线性表。",
42,串的基本操作,"1）串的置空操作：clear(  )；2）串的判空操作：isEmpty(  )；3）求串的长度操作：length(  )；4）取字符元素操作：charAT(index)；5）截取子串操作：substring( bengin,end )；6）插入操作：insert(offset,str )；7）删除操作：delete(begin,end  )；8）串的连接操作：concat(str )；9）串的比较操作：compareTo(str )；10）子串定位操作：indexOf(str, begin)",
43,串的顺序存储结构 ,串的顺序存储结构与线性表的顺序存储结构类似，可以采用一组地址连续的存储单元来存储串字符序列。顺序存储的串称为顺序串。,
44,串的链式存储结构,串的链式存储结构和线性表的链式存储结构类似，可以采用单链表来存储串值，串的这种链式存储结构称为链串。,
45,"截子串操作subString(begin, end)的实现",操作要求：返回当前串中序号从begin至end-1的子串。起始下标begin的范围是：0≤begin≤length()-1；结束下标end的范围是：1≤end≤length()。,
46,"串的插入操作insert(offset, str)的实现",操作要求：在当前串中第offset个字符之前插入串str，并返回结果串对象。其中：参数offset的有效范围是：0≤offset≤length()。当offset=0，表示在当前串的开始处插入串str；当offset= length()，表示在当前串的结尾处插入串str。,
47,"串的删除操作delete(begin, end)的实现",操作要求：在当前串中删除从begin到end-1之间的子串，并返回当前串对象。,
48,串的比较操作compareTo(str)的实现,"操作要求：将当前串与目标串str进行比较,若:当前串 > str，则返回值 > 0；当前串?= str，则返回值 = 0； 当前串 < str，则返回值 < 0。",
49,"子串的定位操作indexOf(str,beging)的实现","操作要求：在当前串中从begin位置开始去找与非空串str相等的子串,若查找成功则返回在当前串中的位置,否则返回-1,其中:  0≤begin≤length()-1。",
50,"串的置换操作 replace(begin,s1,s2)的实现",操作要求：在当前对象串this中，从下标begin开始，将所有的s1非空子串替换为s2非空串。 ,
51,模式匹配,"设s,t 是两个串，s= ""s0s1…sn-1"",t= ""t0t1…tm-1""(0≤m≤<n)在s串中寻找等于t的子串的过程称为模式匹配。",
52,模式串的next函数,模式串中，每一个tj都有一个k值对应，这个k值仅与模式串本身有关，而与主串s无关。一般用next[j]函数来表示tj对应的k值。,
53,数组,"数组是n(n≥1)个具有相同类型的数据元素a0,a1,…,an-1构成的有限序列，并且这些数据元素占用一片地址连续的内存单元。其中：n称为数组的长度。",
54,数组的顺序存储结构,数组的顺序存储表示要解决的是一个"如何用一维的存储地址来表示多维的关系"的问题。,
55,压缩存储,压缩存储是指为多个值相同的元只分配一个存储空间；对零元不分配空间。,
56,树,树是由n（n≥0）个结点所构成的有限集合，当n=0时，称为空树；当n>0时，n个结点满足以下条件：⑴ 有且仅有一个称为根的结点。⑵ 其余结点可分为m（m≥0）个互不相交的有限集合，且每一个集合又构成一棵树，这棵树称为是根结点的子树。,
57,分支,指根和子树根之间的连线(边)。,
58,结点,指数据元素+所有关联子树根的分支,
59,结点的路径,由从根到该结点所经分支和结点构成。,
60,结点的度,指结点所拥有子树的数目。,
61,树的度,指树中所有结点的度的最大值。,
62,叶子结点,指度为零的结点。,
63,分支结点,指度大于零的结点,
64,结点的层次,假设根结点的层次为0，则其它结点的层次是其双亲结点的层次数加1。,
65,树的深度,指树中所有结点层次数的最大值加1。,
66,有序树,指树中各结点的所有子树之间从左到右有严格的次序关系。,
67,无序树,与有序树相反，无序树是指树中各结点的所有子树之间没有严格的次序关系。,
68,森林,是由m（m≥0）棵互不相交的树所构成的集合。,
69,二叉树,二叉树或为空树，或是由一个根结点加上两棵分别称为左子树和右子树的、互不交的二叉树组成。,
70,满二叉树,如果在一棵二叉树中，它的所有结点或者是叶结点，或者是左、右子树都非空，并且所有叶结点都在同一层上，则称这棵二叉树为满二叉树。,
71,完全二叉树,如果在一棵具有n个结点的二叉树中，它的逻辑结构与满二叉树的前n个结点的逻辑结构相同，则称这样的二叉树为完全二叉树。,
72,左支树,指所有结点都没有右孩子的二叉树。,
73,右支树,指所有结点都没有左孩子的二叉树。,
74,二叉树的顺序存储结构,指将二叉树的所有结点，按照一定的顺序（层序），存储到一片连续的存储单元中。适合存储满二叉树。,
75,遍历,指沿着某一条搜索路径对二叉树中的结点进行访问，使得每个结点均被访问一次，而且仅被访问一次。,
76,层次遍历,若二叉树为空，则为空操作；否则，按自上而下先访问第0层的根结点，然后再从左到右依次访问各层次中的每一个结点。,
77,先根遍历操作的非递归实现,基本步骤：① 创建一个栈对象，根结点入栈；② 当栈为非空时，将栈顶结点弹出栈内并访问该结点；③ 对当前访问结点的非空左孩子结点相继依次访问，并将当前访问结点的非空右孩子结点压入栈内；④ 重复执行步骤②和③，直到栈为空为止。,
78,中根遍历操作的非递归实现,基本步骤：① 创建一个栈对象，根结点入栈；②若栈顶结点非空，则将栈顶结点的非空左孩子相继进栈；③栈顶结点出栈并访问非空栈顶结点，再使该栈顶结点的非空右孩子结点入栈；④重复执行步骤②和③，直到栈为空为止。,
79,后根遍历操作的非递归实现,基本步骤：① 创建一个栈对象，根结点入栈，p赋初始值null；②若栈顶结点非空，则将栈顶结点的非空左孩子相继进栈；③若栈非空，查看栈顶结点，若栈顶结点的右孩子为空，或者与p相等，则将栈顶结点弹出栈并访问它，同时使p指向该结点，并置flag值为true；否则，将栈顶结点的右孩子压入栈，并置flag值为false。④若flag值为true，则重复执行步骤③；否则，重复执行步骤②和③，直到栈为空为止。,
80,层次遍历操作的非递归实现,基本步骤：①创建一个链队列对象，根结点入队；②若队列非空，重复将队首结点出队并访问该结点，再将该结点的非空左、右孩子结点依次入队，直到队列为空为止。,
81,结点间的路径,指从一个结点到另一个结点所经历的结点和分支序列。,
82,结点的路径长度,指从根结点到该结点的路径上分支的数目。,
83,结点的权,在实际应用中，人们往住会给树中的每一个结点赋予一个具有某种实际意义的数值，这个数值被称为该结点的权值。 ,
84,结点的带权路径长度,指结点的路径长度与该结点的权值的乘积。,
85,树的带权路径长度,指树中所有叶结点的带权路径长度之和 。,
86,最优二叉树,给定n个权值并作为n个叶结点按一定规则构造一棵二叉树，使其带权路径长度达到最小值，则这棵二叉树被称为最优二叉树。也称哈夫曼树。,
87,先根遍历,若树非空，则进行如一操作:（1）访问根结点；（2）从左到右依次先根遍历根结点的每一棵子树。,
88,后根遍历,若树非空，则进行如一操作:（1）从左到右依次后根遍历根结点的每一棵子树；（2）访问根结点。,
89,层次遍历,若树为非空，则从根结点开始，从上到下依次访问每一层的各个结点，在同一层中的结点，则按从左到右的顺序依次进行访问。,
90,图,"由顶点（Vertex）集和边( Edge）集组成，记为 G＝（V，E）,其中V 是有穷非空集合，称为顶点集，v ∈ V 称为顶点。E 是有穷集合，称为边集， e∈ E 称为边。",
91,权,在一个图中，每条边可以标上具有某种含义的数值，此数值称为该边上的权；通常权是一个非负实数；权可以表示从一个顶点到另一个顶点的距离、时间或代价等含义。,
92,网,边上标识权的图称为网。,
93,稀疏图,若边或弧的个数 e<nlogn，则称作稀疏图。,
94,子图,"设有两个图G＝(V,  E)和G’＝(V ’,  E ’) ，若V ’是V 的子集，即V ’ ? V ，并且E ’是E 的子集，即E ’ ? E ，则称G’为G的子图，记为G’? G 。",
95,邻接点,"在一个无向图中，若存在一条边(u,v)，则称顶点u与v互为邻接点。边(u,v)是顶点u和v关联的边，顶点u和v是边(u,v)关联的顶点。",
96,顶点的度,顶点的度是图中与该顶点相关联边的数目，记为D(v)。,
97,无向图顶点的度,定义为以该顶点为一个端点的边的数目，即该顶点的边的数目，记为D(v) 。,
98,路径,"在一个图中，路径是从顶点u到顶点v所经过的顶点序列，即(u=vi0, vi1, …, vim=v)。",
99,回路,第一个顶点和最后一个顶点相同的路径称为回路或环。,
100,初等路径,序列中顶点不重复出现的路径称为初等路径。,
101,初等回路,指除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。,
102,网中的路径长度,在网中，从始点到终点的路径上各边的权值之和，称为路径长度。,
103,强连通图,若有向图中任意两个顶点之间都存在一条有向路径，则称此有向图为强连通图。,
104,生成树,假设一个连通图有??个顶点和??条边，其中???1条边和??个顶点构成一个极小连通子图，称该极小连通子图为此连通图的生成树。,
105,生成森林,对非连通图，则称由各个连通分量的生成树的集合为此非连通图的生成森林。,
106,邻接表,由一个顺序存储的顶点表和n个链式存储的边表组成的,
107,无向网的创建算法,算法处理步骤:1、输入顶点数和边数 2、构造顶点向量 3、根据图的边数，确定输入边的数目 4、根据输入的每条边生成边结点，并在相应位置插入边结点  ,
108,图的遍历,从图中的某个顶点出发，对图中的所有顶点访问且仅访问一次的过程。,
109,广度优先搜索,从图中的某个顶点v开始，先访问该顶点再依次访问该顶点的每一个未被访问过的邻接点 w1、w2、…；然后按此顺序访问顶点w1、w2、… 的各个还未被访问过的邻接点；重复上述过程，直到图中的所有顶点都被访问过为止。,
110,空间复杂度,需要使用队列，依次记住被访问过的顶点，每一个顶点最多入队、出队一次，空间复杂度为O(n)。,
111,深度优先搜索遍历,从图中某个顶点V0 出发，访问此顶点，然后依次从V0的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和V0有路径相通的顶点都被访问到。,
112,时间复杂度,存储结构采用邻接矩阵时，需要扫描邻接 矩阵中的每一个顶点，其时间复杂度为O(n2)；当图的存储结构采用邻接表时，需要扫描邻接表中的每一个单链表，其时间复杂度为O（e）。,
113,连通图的生成树,是图的极小连通子图，它包含图中的全部顶点；是图的极大无回路子图，它的边集是关联图中的所有顶点而又没有形成回路的边；一个有n个顶点的连通图的生成树只能有n-1条边；图的生成树不是唯一的。,
114,最小生成树,在一个网的所有生成树中，权值总和最小的生成树称为最小代价生成树。,
115,拓扑排序,检查有向图中是否存在回路的方法之一，是对有向图进行拓扑排序。,
116,AOE(Activity On Edge)网,若以弧表示活动，弧上的权值表示进行该项活动所需的时间，以顶点表示“事件（Event）”，称这种有向网为边活动网络，简称为AOE(Activity On Edge)网。,
117,源点,表示工程开始事件的顶点的入度为零。,
118,汇点,表示工程结束事件的顶点的出度为零。,
119,关键路径,由于AOE网中某些活动可以并行进行，故完成整个工程的最短时间即为从源点到汇点最长路径的长度，这条路径称为关键路径。,
120,排序,"一般情况下，假设含n个记录的序列为{ r0, r1, …， rn-1 }，其相应的关键字序列为 { K0, K1, …，Kn-1 }，这些关键字相互之间可以进行比较，且在它们之间存在着这样一个关系 ： Kp1≤Kp2≤…≤Kpn，按此固有关系将上式记录序列重新排列为{ rp1, rp2, …，rpn }的操作称作排序。",
121,插入排序,每次将一个待排序的记录，按其关键字值的大小插入到前面已排序好的记录序列中的适当位置，直到全部记录插入完成为止。,
122,冒泡排序,将待排序的数组看成从上到下的存放，把关键字较小的记录看成“较轻的”，关键字较大的记录看成“较重的”，小关键字的记录好像水中的气泡一样，向上浮；大关键字的记录如水中的石块向下沉，当所有的气泡都浮到了相应的位置，且所有的石块都沉到了水中，排序就结束了。,
123,快速排序,通过一趟排序将要排序的记录分割成独立的两个部分，其中一部分的所有记录的关键字值都比另外一部分的所有记录关键字值小，然后再按此方法对这两部分记录分别进行快速排序，整个排序过程可以递归进行，以此达到整个记录序列变成有序。,
124,直接选择排序,首先在所有记录中选出关键字值最小的记录，把它与第一个记录进行位置交换，然后在其余的记录中再选出关键字值次小的记录与第二个记录进行位置交换，依此类推，直到所有记录排好序。 ,
125,树形选择排序,首先针对n个记录进行两两比较，比较的结果是把关键字值较小者作为优胜者上升到父结点，得到个比较的优胜者(关键字值较小者)，作为第一步比较的结果保留下来；然后对这个记录再进行关键字的两两比较，如此重复，直到选出一个关键字值最小的记录为止。,
126,堆排序,首先把待排序的记录序列对应成一棵完全二叉树，并把它转换成一个初始堆（即首先建初始堆）。这时，根结点具有最大（或最小）的关键字值，然后，交换根结点和最后一个结点（即第n个结点）的位置，除最后一个结点之外，前n-1个结点仍构成一棵完全二叉树，再把它们调整为一个堆。同样交换根结点和最后一个结点（即第n-1个结点）。重复进行下去，直到只剩下一个根结点为止，便得一个有序表。,
127,多关键字的排序,"n 个记录的序列  { r0, r1, …，rn-1}对关键字 (ki0, ki1,…,kid-1) 有序是指：对于序列中任意两个记录 ri 和 rj(1≤i<j≤n) 都满足下列(词典)有序关系：(ki0, ki1, …,kid-1) <  (kj0, kj1, …,kjd-1)",
128,查找,所谓查找，就是在由一组记录组成的集合中寻找主关键字值等于给定值的某个记录，或是寻找属性值符合特定条件的某些记录。 ,
129,查找表,查找表是一种以同一类型的记录构成的集合为逻辑结构，以查找为核心运算的数据结构。 ,
130,查找成功,若查找表中存在这样一个记录，则称“查找成功”。查找结果给出整个记录的信息，或指示该记录在查找表中的位置；,
131,查找不成功,若在查找表中不存在这样的记录，则称“查找不成功”。查找结果给出“空记录”或“空指针”。,
132,平均查找长度,指为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值。,
133,顺序查找,指从顺序表的一端开始，依次将每一个数据元素的关键字值与给定值key进行比较，若某个数据元素的关键字值等于给定值key，则表明查找成功；若直到所有数据元素都比较完毕，仍找不到关键字值为key的数据元素，则表明查找失败。,
134,二分查找,取出表中的中间元素，若其关键字值为key，则查找成功，算法结束；否则以中间元素为分界点，将查找表分成两个子表，并判断所查的key值所在的子表是前部分，还是后部分，再重复上述步骤直到找到关键字值为key的元素或子表长度为0。,
135,索引顺序表的查找过程,1）由索引确定记录所在块（区间）；2）在顺序表的某个块内进行查找。,
136,二叉排序树,二叉排序树或者是一棵空树；或者是具有如下特性的二叉树：1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值；2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值；3）它的左、右子树也都分别是二叉排序树。,
137,平衡二叉树,它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树或右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。,
138,平衡因子,该结点的左子树的深度减去它右子树的深度。,
139,B-树,"一棵m阶(m>=3)B-树，或为空树，或为满足下列特征的m叉树。⑴ 树中每个结点至多有m棵子树。 ⑵ 若根结点不是叶子结点，则至少有两棵子树。 ⑶ 所有的非终端结点中包含下列信息：(n, P0 ,K1 ,P1 ,K2 ,P2 ,…,Kn ,Pn)",
140,红黑树,红黑树是一种每一个结点都带有颜色属性的二叉查找树，颜色或是红色或是黑色。可以把一棵红黑树视为一棵扩充的二叉树，用外部结点表示空指针。,
141,哈希表,根据设定的哈希函数 H(key) 和所选中的处理冲突的方法，将一组关键字映象到一个有限的、地址连续的地址集 (区间) 上，并以关键字在地址集中的“象”作为相应记录在表中的存储位置，如此构造所得的查找表称之为“哈希表”。,
142,数字分析法,"假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)，分析关键字集中的全体， 并从中提取分布均匀的若干位或它们的组合作为地址。",
143,平方取中法,以关键字的平方值的中间几位作为存储地址。求“关键字的平方值” 的目的是“扩大差别” ，同时平方值的中间各位又能受到整个关键字中各位的影响。,
144,折叠法,将关键字分割成若干部分，然后取它们的叠加和为哈希地址。有两种叠加处理的方法：移位叠加和间界叠加。,
